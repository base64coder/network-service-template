package com.dtc.core.extensions;

import com.dtc.core.extensions.model.ExtensionMetadata;
import net.bytebuddy.ByteBuddy;
import net.bytebuddy.dynamic.loading.ClassLoadingStrategy;
import net.bytebuddy.implementation.MethodDelegation;
import net.bytebuddy.matcher.ElementMatchers;
import org.slf4j.Logger;
import org.slf4j.LoggerFactory;

import java.lang.reflect.Constructor;
import java.lang.reflect.Method;
import java.util.Arrays;
import java.util.Map;
import java.util.concurrent.ConcurrentHashMap;

/**
 * ByteBuddy å·¥å‚å·¥å…·ç±»
 * æä¾›åº•å±‚çš„ ByteBuddy æ“ä½œæ”¯æŒ
 * 
 * @author Network Service Template
 */
public class ByteBuddyFactory {

    private static final Logger log = LoggerFactory.getLogger(ByteBuddyFactory.class);
    private static final Map<String, Class<?>> CLASS_CACHE = new ConcurrentHashMap<>();
    private static final Map<String, Object> INSTANCE_CACHE = new ConcurrentHashMap<>();

    /**
     * åˆ›å»º ByteBuddy å¢å¼ºç±»
     * 
     * @param originalClass åŸå§‹ç±»
     * @param classLoader   ç±»åŠ è½½å™¨
     * @param extensionId   æ‰©å±•ID
     * @return å¢å¼ºç±»
     */
    @SuppressWarnings("unchecked")
    public static <T> Class<? extends T> createEnhancedClass(Class<T> originalClass,
            ClassLoader classLoader,
            String extensionId) {
        String cacheKey = generateCacheKey(originalClass.getName(), classLoader);

        return (Class<? extends T>) CLASS_CACHE.computeIfAbsent(cacheKey, key -> {
            try {
                log.info("ğŸ”§ Generating ByteBuddy enhanced class for: {} with key: {}", originalClass.getName(),
                        cacheKey);
                log.info("ğŸ”§ ClassLoader: {}", classLoader.getClass().getName());
                log.info("ğŸ”§ Extension ID: {}", extensionId);

                Class<? extends T> enhancedClass = new ByteBuddy()
                        .subclass(originalClass)
                        .method(ElementMatchers.any())
                        .intercept(MethodDelegation.to(new ExtensionMethodInterceptor(originalClass, extensionId)))
                        .make()
                        .load(classLoader, ClassLoadingStrategy.Default.INJECTION)
                        .getLoaded();

                log.info("âœ… Successfully generated ByteBuddy enhanced class: {} (original: {})",
                        enhancedClass.getName(), originalClass.getName());
                return enhancedClass;

            } catch (Exception e) {
                log.error("âŒ Failed to generate ByteBuddy enhanced class for: {} - Error: {}",
                        originalClass.getName(), e.getMessage(), e);
                log.warn("âš ï¸ Using original class instead of enhanced version");
                return originalClass; // å›é€€åˆ°åŸå§‹ç±»
            }
        });
    }

    /**
     * è·å–æˆ–åˆ›å»ºæ‰©å±•å®ä¾‹ï¼ˆåˆ†å±‚ç­–ç•¥ï¼‰
     * 
     * @param originalClass åŸå§‹ç±»
     * @param classLoader   ç±»åŠ è½½å™¨
     * @param extensionId   æ‰©å±•ID
     * @param args          æ„é€ å‡½æ•°å‚æ•°
     * @return æ‰©å±•å®ä¾‹
     */
    @SuppressWarnings("unchecked")
    public static <T> T getOrCreateInstance(Class<T> originalClass,
            ClassLoader classLoader,
            String extensionId,
            Object... args) {
        String cacheKey = generateCacheKey(originalClass.getName(), classLoader);

        // ä¼˜å…ˆçº§1: æ£€æŸ¥ç¼“å­˜
        Object cachedInstance = INSTANCE_CACHE.get(cacheKey);
        if (cachedInstance != null) {
            log.debug("Found cached instance for: {} with key: {}", originalClass.getName(), cacheKey);
            return (T) cachedInstance;
        }

        log.info("ğŸ” Creating new instance for: {} with key: {}", originalClass.getName(), cacheKey);
        log.info("ğŸ” ClassLoader: {}", classLoader.getClass().getName());
        log.info("ğŸ” Extension ID: {}", extensionId);
        log.info("ğŸ” Args count: {}", args != null ? args.length : 0);

        T instance = null;
        Exception lastException = null;

        // ä¼˜å…ˆçº§2: å°è¯•æ— å‚æ„é€ å‡½æ•°
        try {
            log.info("ğŸ” Attempting no-arg constructor for: {}", originalClass.getName());
            instance = tryNoArgConstructor(originalClass);
            if (instance != null) {
                log.info("âœ… Successfully created instance using no-arg constructor for: {}", originalClass.getName());
            }
        } catch (Exception e) {
            log.warn("âŒ No-arg constructor failed for: {} - Error: {}", originalClass.getName(), e.getMessage());
            lastException = e;
        }

        // ä¼˜å…ˆçº§3: å°è¯•å¯æ³¨å…¥æ„é€ å‡½æ•°
        if (instance == null) {
            try {
                instance = tryInjectableConstructor(originalClass, args);
                if (instance != null) {
                    log.debug("Successfully created instance using injectable constructor for: {}",
                            originalClass.getName());
                }
            } catch (Exception e) {
                log.debug("Injectable constructor failed for: {}", originalClass.getName(), e);
                lastException = e;
            }
        }

        // ä¼˜å…ˆçº§4: å°è¯• ByteBuddy åŠ¨æ€å­ç±»/ä»£ç†
        if (instance == null) {
            try {
                log.info("ğŸ” Attempting ByteBuddy enhancement for: {}", originalClass.getName());
                instance = tryByteBuddyEnhancement(originalClass, classLoader, extensionId, args);
                if (instance != null) {
                    log.info("âœ… Successfully created instance using ByteBuddy enhancement for: {}",
                            originalClass.getName());
                }
            } catch (Exception e) {
                log.error("âŒ ByteBuddy enhancement failed for: {} - Error: {}", originalClass.getName(), e.getMessage(),
                        e);
                lastException = e;
            }
        }

        // ä¼˜å…ˆçº§5: ç®€å•åŒ…è£…
        if (instance == null) {
            try {
                instance = createSimpleWrapper(originalClass, extensionId);
                log.debug("Successfully created simple wrapper for: {}", originalClass.getName());
            } catch (Exception e) {
                log.error("All creation strategies failed for: {}", originalClass.getName(), e);
                if (lastException != null) {
                    throw new RuntimeException("Failed to create instance for: " + originalClass.getName(),
                            lastException);
                }
                throw new RuntimeException("Failed to create instance for: " + originalClass.getName(), e);
            }
        }

        // ç¼“å­˜å®ä¾‹
        if (instance != null) {
            INSTANCE_CACHE.put(cacheKey, instance);
            log.debug("Cached instance for: {} with key: {}", originalClass.getName(), cacheKey);
        }

        return instance;
    }

    /**
     * ç”Ÿæˆç¼“å­˜é”®
     */
    private static String generateCacheKey(String className, ClassLoader classLoader) {
        int classLoaderHash = System.identityHashCode(classLoader);
        return className + ":" + classLoaderHash;
    }

    /**
     * å°è¯•æ— å‚æ„é€ å‡½æ•°
     */
    private static <T> T tryNoArgConstructor(Class<T> clazz) throws Exception {
        log.info("ğŸ” Looking for no-arg constructor in: {}", clazz.getName());
        log.info("ğŸ” Available constructors:");
        for (Constructor<?> c : clazz.getDeclaredConstructors()) {
            log.info("ğŸ”   - {}", c);
        }

        Constructor<T> constructor = clazz.getDeclaredConstructor();
        log.info("ğŸ” Found no-arg constructor: {}", constructor);
        constructor.setAccessible(true);
        log.info("ğŸ” Calling constructor.newInstance() for: {}", clazz.getName());
        T instance = constructor.newInstance();
        log.info("ğŸ” Successfully created instance: {}", instance.getClass().getName());
        return instance;
    }

    /**
     * å°è¯•å¯æ³¨å…¥æ„é€ å‡½æ•°
     */
    @SuppressWarnings("unchecked")
    private static <T> T tryInjectableConstructor(Class<T> clazz, Object... args) throws Exception {
        Constructor<?>[] constructors = clazz.getDeclaredConstructors();

        for (Constructor<?> constructor : constructors) {
            if (constructor.getParameterCount() == args.length) {
                try {
                    constructor.setAccessible(true);
                    Object[] processedArgs = unwrapAndCoerceArgs(constructor.getParameterTypes(), args);
                    return (T) constructor.newInstance(processedArgs);
                } catch (Exception e) {
                    log.debug("Constructor {} failed, trying next", constructor, e);
                }
            }
        }

        throw new NoSuchMethodException("No suitable constructor found for " + clazz.getName());
    }

    /**
     * å°è¯• ByteBuddy å¢å¼º
     */
    @SuppressWarnings("unchecked")
    private static <T> T tryByteBuddyEnhancement(Class<T> originalClass,
            ClassLoader classLoader,
            String extensionId,
            Object... args) throws Exception {
        log.info("ğŸ” Creating enhanced class for: {}", originalClass.getName());
        Class<? extends T> enhancedClass = createEnhancedClass(originalClass, classLoader, extensionId);
        log.info("ğŸ” Enhanced class created: {} (original: {})",
                enhancedClass.getName(), originalClass.getName());

        log.info("ğŸ” Finding matching constructor for enhanced class: {}", enhancedClass.getName());
        Constructor<?> constructor = findMatchingConstructor(enhancedClass, args);
        log.info("ğŸ” Found constructor: {}", constructor);

        log.info("ğŸ” Processing constructor arguments...");
        Object[] processedArgs = unwrapAndCoerceArgs(constructor.getParameterTypes(), args);
        log.info("ğŸ” Processed {} arguments", processedArgs.length);

        log.info("ğŸ” Creating instance with constructor: {}", constructor);
        T instance = (T) constructor.newInstance(processedArgs);
        log.info("ğŸ” Instance created successfully: {}", instance.getClass().getName());

        return instance;
    }

    /**
     * åˆ›å»ºç®€å•åŒ…è£…
     */
    @SuppressWarnings("unchecked")
    private static <T> T createSimpleWrapper(Class<T> clazz, String extensionId) {
        log.warn("âš ï¸ Creating simple wrapper for: {} (ByteBuddy enhancement failed)", clazz.getName());
        if (NetworkExtension.class.isAssignableFrom(clazz)) {
            return (T) new NetworkExtension() {
                @Override
                public String getId() {
                    return extensionId;
                }

                @Override
                public String getName() {
                    return clazz.getSimpleName();
                }

                @Override
                public String getVersion() {
                    return "1.0.0";
                }

                @Override
                public String getAuthor() {
                    return "System";
                }

                @Override
                public int getPriority() {
                    return 0;
                }

                @Override
                public int getStartPriority() {
                    return 0;
                }

                @Override
                public ExtensionMetadata getMetadata() {
                    return ExtensionMetadata.builder()
                            .id(getId())
                            .name(getName())
                            .version(getVersion())
                            .author(getAuthor())
                            .priority(getPriority())
                            .startPriority(getStartPriority())
                            .build();
                }

                @Override
                public java.nio.file.Path getExtensionFolderPath() {
                    return java.nio.file.Paths.get("extensions", getId());
                }

                @Override
                public ClassLoader getExtensionClassloader() {
                    return clazz.getClassLoader();
                }

                @Override
                public void start() throws Exception {
                    log.info("Simple wrapper started for: {}", clazz.getName());
                    log.warn("âš ï¸ This is a simple wrapper - the real extension start() method is not being called!");
                    log.warn("âš ï¸ To fix this, ByteBuddy enhancement must work properly.");

                    // ä¸´æ—¶è§£å†³æ–¹æ¡ˆï¼šå°è¯•åˆ›å»ºçœŸæ­£çš„æ‰©å±•å®ä¾‹å¹¶è°ƒç”¨å…¶ start() æ–¹æ³•
                    try {
                        log.info("ğŸ”§ Attempting to create real extension instance for testing...");
                        Object realInstance = clazz.getDeclaredConstructor().newInstance();
                        log.info("ğŸ”§ Created real instance: {}", realInstance.getClass().getName());

                        // è°ƒç”¨çœŸæ­£çš„ start() æ–¹æ³•
                        Method startMethod = clazz.getMethod("start");
                        startMethod.invoke(realInstance);
                        log.info("âœ… Successfully called real extension start() method!");

                    } catch (Exception e) {
                        log.error("âŒ Failed to create/call real extension instance", e);
                    }
                }

                @Override
                public void stop() throws Exception {
                    log.info("Simple wrapper stopped for: {}", clazz.getName());
                }

                @Override
                public boolean isEnabled() {
                    return true;
                }

                @Override
                public void setEnabled(boolean enabled) {
                    // ç®€å•åŒ…è£…ä¸æ”¯æŒç¦ç”¨
                }

                @Override
                public boolean isStarted() {
                    return true;
                }

                @Override
                public boolean isStopped() {
                    return false;
                }

                @Override
                public void cleanup(boolean disable) {
                    log.info("Simple wrapper cleaned up for: {}", clazz.getName());
                }
            };
        }

        // å¦‚æœä¸æ˜¯ NetworkExtensionï¼Œå°è¯•åˆ›å»ºåŸå§‹ç±»çš„å®ä¾‹
        try {
            return tryNoArgConstructor(clazz);
        } catch (Exception e) {
            throw new RuntimeException("Cannot create simple wrapper for: " + clazz.getName(), e);
        }
    }

    /**
     * æ¸…ç†ç¼“å­˜
     */
    public static void clearCache() {
        CLASS_CACHE.clear();
        INSTANCE_CACHE.clear();
        log.info("Cleared all caches");
    }

    /**
     * æ¸…ç†ç‰¹å®šç±»çš„ç¼“å­˜
     */
    public static void clearCacheForClass(String className, ClassLoader classLoader) {
        String cacheKey = generateCacheKey(className, classLoader);
        CLASS_CACHE.remove(cacheKey);
        INSTANCE_CACHE.remove(cacheKey);
        log.debug("Cleared cache for class: {} with key: {}", className, cacheKey);
    }

    /**
     * è·å–ç¼“å­˜ç»Ÿè®¡ä¿¡æ¯
     */
    public static String getCacheStats() {
        return String.format("Class cache size: %d, Instance cache size: %d",
                CLASS_CACHE.size(), INSTANCE_CACHE.size());
    }

    /**
     * åˆ›å»ºå¢å¼ºå®ä¾‹ï¼ˆå·²å¼ƒç”¨ï¼Œè¯·ä½¿ç”¨ ExtensionCreationManagerï¼‰
     * 
     * @deprecated ä½¿ç”¨ ExtensionCreationManager.createEnhancedExtension() æ›¿ä»£
     */
    @Deprecated
    @SuppressWarnings("unchecked")
    public static <T> T createEnhancedInstance(Class<T> originalClass, ClassLoader classLoader, String extensionId,
            Object... args) {
        log.warn("ByteBuddyFactory.createEnhancedInstance() is deprecated, use ExtensionCreationManager instead");

        try {
            log.debug("Creating enhanced instance for {} with {} arguments", originalClass.getName(), args.length);

            Class<? extends T> enhancedClass = createEnhancedClass(originalClass, classLoader, extensionId);

            // å¦‚æœç”Ÿæˆå¤±è´¥ï¼Œå›é€€åˆ°åŸå§‹ç±»
            if (enhancedClass == originalClass) {
                log.debug("Using original class {} instead of enhanced version", originalClass.getName());
                Constructor<?> ctor = findMatchingConstructor(originalClass, args);
                Object[] processedArgs = unwrapAndCoerceArgs(ctor.getParameterTypes(), args);
                T instance = (T) ctor.newInstance(processedArgs);

                // éªŒè¯å®ä¾‹ä¸ä¸ºç©º
                if (instance == null) {
                    throw new RuntimeException(
                            "Constructor returned null instance for original class: " + originalClass.getName());
                }

                return instance;
            }

            Constructor<?> ctor = findMatchingConstructor(enhancedClass, args);
            Object[] processedArgs = unwrapAndCoerceArgs(ctor.getParameterTypes(), args);

            log.debug("Successfully created enhanced instance of {} with constructor {}",
                    originalClass.getName(), ctor);
            T instance = (T) ctor.newInstance(processedArgs);

            // éªŒè¯å®ä¾‹ä¸ä¸ºç©º
            if (instance == null) {
                throw new RuntimeException("Constructor returned null instance for: " + originalClass.getName());
            }

            return instance;
        } catch (Exception e) {
            log.error("Failed to create enhanced instance of {} with {} arguments",
                    originalClass.getName(), args != null ? args.length : 0, e);
            throw new RuntimeException("Failed to create enhanced instance of " + originalClass.getName(), e);
        }
    }

    /**
     * è‡ªåŠ¨åŒ¹é…æ„é€ å‡½æ•°
     */
    private static Constructor<?> findMatchingConstructor(Class<?> clazz, Object[] args) throws NoSuchMethodException {
        if (args == null || args.length == 0) {
            // å°è¯•æ— å‚æ„é€ å‡½æ•°
            try {
                Constructor<?> noArgCtor = clazz.getDeclaredConstructor();
                noArgCtor.setAccessible(true);
                return noArgCtor;
            } catch (NoSuchMethodException e) {
                // ç»§ç»­å°è¯•å…¶ä»–æ„é€ å‡½æ•°
            }
        }

        Class<?>[] argTypes = Arrays.stream(args)
                .map(arg -> arg != null ? arg.getClass() : Object.class)
                .toArray(Class<?>[]::new);

        log.debug("Looking for constructor in {} with {} arguments: {}",
                clazz.getName(), args != null ? args.length : 0, Arrays.toString(argTypes));

        // é¦–å…ˆå°è¯•ç²¾ç¡®åŒ¹é…
        for (Constructor<?> c : clazz.getDeclaredConstructors()) {
            Class<?>[] paramTypes = c.getParameterTypes();
            if (paramTypes.length == (args != null ? args.length : 0)) {
                boolean exactMatch = true;
                for (int i = 0; i < paramTypes.length; i++) {
                    if (args != null && args[i] != null && !paramTypes[i].isAssignableFrom(args[i].getClass())) {
                        exactMatch = false;
                        break;
                    }
                }
                if (exactMatch) {
                    log.debug("Found exact constructor match: {}", c);
                    c.setAccessible(true);
                    return c;
                }
            }
        }

        // ç„¶åå°è¯•å…¼å®¹åŒ¹é…
        for (Constructor<?> c : clazz.getDeclaredConstructors()) {
            if (isCompatible(c.getParameterTypes(), argTypes)) {
                log.debug("Found compatible constructor: {}", c);
                c.setAccessible(true);
                return c;
            }
        }

        // å¦‚æœè¿˜æ˜¯æ‰¾ä¸åˆ°ï¼Œå°è¯•å¼ºåˆ¶åŒ¹é…ï¼ˆå¿½ç•¥ç±»å‹æ£€æŸ¥ï¼‰
        for (Constructor<?> c : clazz.getDeclaredConstructors()) {
            if (c.getParameterCount() == (args != null ? args.length : 0)) {
                log.debug("Found constructor with matching parameter count: {}", c);
                c.setAccessible(true);
                return c;
            }
        }

        // æœ€åå°è¯•ï¼šå¦‚æœæ˜¯ByteBuddyç”Ÿæˆçš„å­ç±»ï¼Œå°è¯•ä½¿ç”¨çˆ¶ç±»æ„é€ å‡½æ•°
        if (clazz.getName().contains("ByteBuddy")) {
            log.debug("Attempting to use parent class constructor for ByteBuddy subclass: {}", clazz.getName());
            return findParentClassConstructor(clazz, args);
        }

        throw new NoSuchMethodException("No compatible constructor found for " + clazz.getName() +
                " with " + (args != null ? args.length : 0) + " arguments");
    }

    /**
     * æŸ¥æ‰¾çˆ¶ç±»æ„é€ å‡½æ•°ï¼ˆç”¨äºByteBuddyå­ç±»ï¼‰
     */
    private static Constructor<?> findParentClassConstructor(Class<?> clazz, Object[] args)
            throws NoSuchMethodException {
        Class<?> parentClass = clazz.getSuperclass();
        if (parentClass == null || parentClass == Object.class) {
            throw new NoSuchMethodException("No parent class constructor found for " + clazz.getName());
        }

        log.debug("Looking for parent class constructor in: {}", parentClass.getName());

        // å°è¯•åœ¨çˆ¶ç±»ä¸­æŸ¥æ‰¾åŒ¹é…çš„æ„é€ å‡½æ•°
        for (Constructor<?> c : parentClass.getDeclaredConstructors()) {
            if (c.getParameterCount() == args.length) {
                log.debug("Found parent class constructor: {}", c);
                c.setAccessible(true);
                return c;
            }
        }

        // é€’å½’æŸ¥æ‰¾çˆ¶ç±»çš„çˆ¶ç±»
        return findParentClassConstructor(parentClass, args);
    }

    /**
     * è§£åŒ… DefaultWrapper å¹¶è‡ªåŠ¨è£…ç®±/ç±»å‹é€‚é…
     */
    private static Object[] unwrapAndCoerceArgs(Class<?>[] paramTypes, Object[] args) {
        Object[] result = new Object[args.length];
        for (int i = 0; i < args.length; i++) {
            Object arg = args[i];
            Class<?> expected = paramTypes[i];

            // è§£åŒ… DefaultWrapper
            if (arg != null && arg.getClass().getSimpleName().equals("DefaultWrapper")) {
                try {
                    Method get = arg.getClass().getMethod("get");
                    arg = get.invoke(arg);
                    log.debug("Unwrapped DefaultWrapper: {} -> {}", arg.getClass().getName(), expected.getName());
                } catch (Exception e) {
                    log.debug("Failed to unwrap DefaultWrapper: {}", e.getMessage());
                }
            }

            // ç±»å‹è½¬æ¢å’Œé€‚é…
            if (arg != null) {
                arg = coerceArgument(arg, expected);
            }

            result[i] = arg;
        }
        return result;
    }

    /**
     * å¼ºåˆ¶ç±»å‹è½¬æ¢å‚æ•°
     */
    private static Object coerceArgument(Object arg, Class<?> expectedType) {
        if (arg == null) {
            return null;
        }

        Class<?> argType = arg.getClass();

        // å¦‚æœç±»å‹å·²ç»åŒ¹é…ï¼Œç›´æ¥è¿”å›
        if (expectedType.isAssignableFrom(argType)) {
            return arg;
        }

        // å¤„ç†åŸºæœ¬ç±»å‹å’ŒåŒ…è£…ç±»å‹
        if (expectedType.isPrimitive()) {
            Class<?> wrapperType = wrapperOrSame(expectedType);
            if (wrapperType.isAssignableFrom(argType)) {
                return arg;
            }
        } else if (argType.isPrimitive()) {
            Class<?> argWrapperType = wrapperOrSame(argType);
            if (expectedType.isAssignableFrom(argWrapperType)) {
                return arg;
            }
        }

        // å°è¯•å¼ºåˆ¶è½¬æ¢
        try {
            if (expectedType == String.class && arg != null) {
                return arg.toString();
            }

            // å¯¹äºæ•°å­—ç±»å‹ï¼Œå°è¯•è½¬æ¢
            if (Number.class.isAssignableFrom(argType) && Number.class.isAssignableFrom(expectedType)) {
                if (expectedType == Integer.class || expectedType == int.class) {
                    return ((Number) arg).intValue();
                } else if (expectedType == Long.class || expectedType == long.class) {
                    return ((Number) arg).longValue();
                } else if (expectedType == Double.class || expectedType == double.class) {
                    return ((Number) arg).doubleValue();
                } else if (expectedType == Float.class || expectedType == float.class) {
                    return ((Number) arg).floatValue();
                }
            }

            // æœ€åå°è¯•ç›´æ¥è½¬æ¢
            return expectedType.cast(arg);
        } catch (Exception e) {
            log.warn("Failed to coerce argument from {} to {}: {}",
                    argType.getName(), expectedType.getName(), e.getMessage());
            return null; // è¿”å›nullä½œä¸ºfallback
        }
    }

    private static boolean isCompatible(Class<?>[] paramTypes, Class<?>[] argTypes) {
        if (paramTypes.length != argTypes.length)
            return false;

        for (int i = 0; i < paramTypes.length; i++) {
            Class<?> expected = paramTypes[i];
            Class<?> actual = argTypes[i];

            if (actual == null) {
                // nullå€¼æ€»æ˜¯å…¼å®¹çš„
                continue;
            }

            // å¤„ç†åŸºæœ¬ç±»å‹å’ŒåŒ…è£…ç±»å‹
            if (expected.isPrimitive()) {
                Class<?> wrapperType = wrapperOrSame(expected);
                if (wrapperType.isAssignableFrom(actual)) {
                    continue;
                }
            } else if (actual.isPrimitive()) {
                Class<?> actualWrapperType = wrapperOrSame(actual);
                if (expected.isAssignableFrom(actualWrapperType)) {
                    continue;
                }
            }

            // ç›´æ¥ç±»å‹æ£€æŸ¥
            if (expected.isAssignableFrom(actual)) {
                continue;
            }

            // ç‰¹æ®Šå¤„ç†ï¼šObjectç±»å‹å¯ä»¥æ¥å—ä»»ä½•ç±»å‹
            if (expected == Object.class) {
                continue;
            }

            // å¦‚æœéƒ½ä¸åŒ¹é…ï¼Œè¿”å›false
            return false;
        }
        return true;
    }

    private static Class<?> wrapperOrSame(Class<?> clazz) {
        if (!clazz.isPrimitive())
            return clazz;
        if (clazz == int.class)
            return Integer.class;
        if (clazz == long.class)
            return Long.class;
        if (clazz == boolean.class)
            return Boolean.class;
        if (clazz == double.class)
            return Double.class;
        if (clazz == float.class)
            return Float.class;
        if (clazz == char.class)
            return Character.class;
        if (clazz == byte.class)
            return Byte.class;
        if (clazz == short.class)
            return Short.class;
        return clazz;
    }
}
